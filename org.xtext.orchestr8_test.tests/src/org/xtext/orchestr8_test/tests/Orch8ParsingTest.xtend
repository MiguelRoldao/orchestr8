/*
 * generated by Xtext 2.26.0
 */
package org.xtext.orchestr8_test.tests

import Orchestr8.Model
import com.google.inject.Inject
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.extensions.InjectionExtension
import org.eclipse.xtext.testing.util.ParseHelper
import org.junit.jupiter.api.Assertions
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.^extension.ExtendWith

@ExtendWith(InjectionExtension)
@InjectWith(Orch8InjectorProvider)
class Orch8ParsingTest {
	@Inject
	ParseHelper<Model> parseHelper
	
	@Test
	// This is the smallest possible valid program
	def void smallestValidProgram() {
		val result = parseHelper.parse('''
			Score my_score {
				@1
					:1.0
						play e4 length 1.0
			}
			
			Mixer my_mixer {
				scores { my_score }
			}
		''')
		Assertions.assertNotNull(result)
		val errors = result.eResource.errors
		Assertions.assertTrue(errors.isEmpty, '''Unexpected errors: «errors.join(", ")»''')
	}
	
	@Test
	// A valid program requires a Mixer.
	def void noMixer() {
		val result = parseHelper.parse('''
			Score my_score {
				@1
					:1.0
						play e4 length 1.0
			}
		''')
		Assertions.assertNotNull(result)
		val errors = result.eResource.errors
		Assertions.assertFalse(errors.isEmpty, '''There should be errors''')
	}
	
	@Test
	// A Score needs at least 1 measure.
	def void noMeasures() {
		val result = parseHelper.parse('''
			Score my_score {}
			
			Mixer my_mixer {
				scores { my_score }
			}
		''')
		Assertions.assertNotNull(result)
		val errors = result.eResource.errors
		Assertions.assertFalse(errors.isEmpty, '''There should be errors''')
	}
	
	@Test
	// Mixer requires at least one score.
	def void noScores() {
		val result = parseHelper.parse('''
			Mixer my_mixer {
				scores {}
			}
		''')
		Assertions.assertNotNull(result)
		val errors = result.eResource.errors
		Assertions.assertFalse(errors.isEmpty, '''There should be errors''')
	}
	
	@Test
	// @Setup should be the first thing in a Score.
	def void outOfPlaceSetup() {
		val result = parseHelper.parse('''
			Score my_score {
				@1
					:1.0
						play e4 length 1.0
				@Setup
					instrument volume 1.0
			}
			
			Mixer my_mixer {
				scores { my_score }
			}
		''')
		Assertions.assertNotNull(result)
		val errors = result.eResource.errors
		Assertions.assertFalse(errors.isEmpty, '''There should be errors''')
	}
	
	@Test
	// A play command should be followed by its length.
	def void incompletePlayCmd() {
		val result = parseHelper.parse('''
			Score my_score {
				@1
					:1.0
						play e4
			}
			
			Mixer my_mixer {
				scores { my_score }
			}
		''')
		Assertions.assertNotNull(result)
		val errors = result.eResource.errors
		Assertions.assertFalse(errors.isEmpty, '''There should be errors''')
	}
	
	@Test
	// A parameter only takes a double value.
	def void stringParameter() {
		val result = parseHelper.parse('''
			Score my_score {
				@Setup
					instrument volume "heloo"
			}
			
			Mixer my_mixer {
				scores { my_score }
			}
		''')
		Assertions.assertNotNull(result)
		val errors = result.eResource.errors
		Assertions.assertFalse(errors.isEmpty, '''There should be errors''')
	}
	
	@Test
	// Multiple measures and beats with the same IDs, is valid.
	// This program is equivalent to:
	//	Score my_score {
	//		@1
	//			:1.0
	//				play e4 length 2.0
	//				instrument volume 0.5
	//	}
	//
	//	Mixer my_mixer {
	//		scores { my_score }
	//	}
	def void multipleMeasures() {
		val result = parseHelper.parse('''
			Score my_score {
				@1
					:1.0
						play e4 length 2.0
				@1
					:1.0
						instrument volume 0.5
			}
			
			Mixer my_mixer {
				scores { my_score }
			}
		''')
		Assertions.assertNotNull(result)
		val errors = result.eResource.errors
		Assertions.assertTrue(errors.isEmpty, '''Unknown errors: «errors.join(", ")»''')
	}
}
